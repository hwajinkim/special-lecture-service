## 클린 & 레이어드 아키텍처를 기반으로 패키지 구조 설계
<img width="488" alt="스크린샷 2024-12-25 오전 1 16 01" src="https://github.com/user-attachments/assets/84d48ea7-9e3a-4d8b-8d48-9b6d36eb2bad" />

### 아키텍처 설계 의도
---
#### 레이어드 아키텍처
* 아키텍처 설계에서 **레이어** 중심(interfaces, application, domain, infrastructure)으로 구분을 하였다. 
구조의 이점으로는 명확한 책임 분리가 가능해지고, 도메인 재사용성 증가하고, 테스트가 용이해진다.

* 명확한 책임 분리
  * 레이어 각각 역할과 책임을 분리하여 서로 독립적으로 동작한다.
    * interfaces 레이어 : 프레젠테이션 및 API 요청 / 응답처리
    * application 레이어 : 애플리케이션 로직 (유즈케이스)처리
    * domain 레이어 : 핵심 비즈니스 로직과 엔티티 관리
    * infrastructure 레이어 : 데이터베이스, 외부 API 등 세부 사항 관리
    * common 레이어 : 공통적으로 사용되는 예외처리, 커스텀 응답 포맷 정의

* 재사용성과 확장성
  * 각 도메인 user, lecture, registration이 독립적인 구조를 가지고 있어서 개별적으로 확장하거나 재사용이 가능하다.
    새로운 기능을 추가하면 한 도메인에만 변경이 집중되어 다른 도메인에 영향을 주지 않게 된다. (OCP, 개방 폐쇄의 원칙)

* 테스트 용이성
  * 계층별로 테스트가 가능하기 때문에 단위테스트와 통합테스트가 수월해진다.

#### 레이어드 아키텍처의 한계와 개선 방향
* 레이어드 구조적 관점으로만 보면 하위 계층에 대한 의존성이 생기므로써 내부가 변경되면 그 영향이 외부로 점차 전파되게 되어 애플리케이션 전체를 변경해야하는 단점이 생긴다. 

#### 클린 아키텍처 개념 적용
* 클린 아키텍처 개념을 추가하여 레이어드 구조는 유지하되,  중심을 비즈니스 로직(도메인 계층) 으로 설정한다. (클린 아키텍처 장점 , 레이어드 아키텍처 장점을 결합)
* 도메인을 최우선으로 두고 나머지 계층은 이를 지원하는 형태로 설계한다.
* 클린 아키텍처 장점
  * 의존성 방향은 바깥 쪽에서 안쪽으로 흐른다.
  * 도메인 계층은 외부 구현 세부 사항에 의존하지 않고 오직 **추상화**에만 의존한다.
  * 비즈니스 로직(도메인 계층)이 가장 안쪽에 위치, 변경으로 부터 보호한다.

1. 의존성 역전 전 <br/>
  controller -> service -> repository -> ORM repository <br/><br/>
  => 직접적인 구현체 의존으로 변경 전파 가능성이 높다.<br/>
  
2. 의존성 역전 후 <br/>
  controller -> service -> repository <- repositoryImpl -> ORM repository <br/><br/>
  => 추상화를 통해 구현체와 분리, 외부 구현 변경이 도메인 계층에 영향을 주지 않는다.

#### 파사드를 활용한 설계
파사드를 활용하여 도메인 별로 분리된 서비스 로직을 한 곳에 모아 어우려저서 동작하게 하였다.
컨트롤러는 파사드 인터페이스만 호출하면 복잡한 서브 시스템의 동작을 이해할 필요가 없어진다.

#### 결론
클린 아키텍처, 레이어드 아키텍처를 결합해서 설계하면 비즈니스 중심 설계를 구현하면서 기존 레이어드 아키텍처의 친숙함과 장점을 유지할 수 있다. 추상화를 통해서 의존성을 역전시킴으로써 코드의 변경이 도메인에 직접적인 영향을 끼치지 않도록 한다.
또한 파사드 패턴을 통해 복잡성을 관리하였다.


